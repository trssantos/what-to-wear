// src/hooks/useGarmentAI.js - ATUALIZA√á√ÉO PARA SUPORTAR ACESS√ìRIOS

import { useState } from 'react';
import { useOpenAI } from './useOpenAI';
import { 
  OPENAI_API_KEY, 
  getClothingCategoriesByGender, 
  getAccessoryCategoriesByGender, // ‚ú® NOVO
  COMMON_COLORS,
  ACCESSORIES_TAGS // ‚ú® NOVO
} from '../utils/constants';

export const useGarmentAI = () => {
  const { callOpenAI } = useOpenAI();
  const [isAnalyzing, setIsAnalyzing] = useState(false);
  const [analysisHistory, setAnalysisHistory] = useState([]);

  // ‚ú® NOVA FUN√á√ÉO: Gerar metadata para acess√≥rios com auto-preenchimento
  const generateAccessoryMetadataWithFormData = async (imageData, userProfile = {}, itemInfo = {}) => {
    if (!OPENAI_API_KEY) {
      throw new Error('API key da OpenAI n√£o configurada no sistema');
    }

    if (!imageData) {
      throw new Error('Imagem do acess√≥rio √© obrigat√≥ria');
    }

    setIsAnalyzing(true);
    
    try {
      // Obter categorias dispon√≠veis baseadas no g√™nero
      const availableCategories = getAccessoryCategoriesByGender(userProfile?.gender);
      
      // Contexto do g√™nero
      const genderContext = userProfile?.gender ? `
PERFIL DO UTILIZADOR:
- G√™nero: ${userProfile.gender}

AN√ÅLISE ESPEC√çFICA POR G√äNERO:
${userProfile.gender === 'female' ? `
- FOCAR EM: Como o acess√≥rio complementa o styling feminino
- CONSIDERAR: Versatilidade para ocasi√µes femininas, eleg√¢ncia
- CATEGORIZA√á√ÉO: Priorizar categorias espec√≠ficas femininas quando aplic√°vel
- NAMING: Usar terminologia feminina apropriada para j√≥ias/acess√≥rios
` : userProfile.gender === 'male' ? `
- FOCAR EM: Como o acess√≥rio se adequa ao styling masculino
- CONSIDERAR: Adequa√ß√£o a dress codes masculinos, sophistication
- CATEGORIZA√á√ÉO: Priorizar categorias espec√≠ficas masculinas quando aplic√°vel
- NAMING: Usar terminologia masculina apropriada
` : `
- FOCAR EM: Versatilidade neutra do acess√≥rio
- CONSIDERAR: Adequa√ß√£o a diferentes express√µes de g√™nero
- CATEGORIZA√á√ÉO: Usar categorias neutras e inclusivas
`}
` : '';

      const prompt = `Como especialista em an√°lise de acess√≥rios e joalharia, analisa esta imagem de um acess√≥rio e gera AUTOMATICAMENTE todos os dados necess√°rios para pr√©-preencher o formul√°rio de adi√ß√£o √† cole√ß√£o de acess√≥rios.

${genderContext}

CATEGORIAS DISPON√çVEIS:
${availableCategories.join(', ')}

CORES DISPON√çVEIS:
${COMMON_COLORS.join(', ')}

TAGS ESPEC√çFICAS PARA ACESS√ìRIOS:
${ACCESSORIES_TAGS.join(', ')}

INFORMA√á√ïES FORNECIDAS PELO UTILIZADOR:
- Nome: ${itemInfo.name || 'N√£o especificado'}
- Categoria: ${itemInfo.category || 'N√£o especificada'}
- Cor: ${itemInfo.color || 'N√£o especificada'}
- Marca: ${itemInfo.brand || 'N√£o especificada'}
- Tags: ${itemInfo.tags?.join(', ') || 'Nenhuma'}
- Notas do utilizador: ${itemInfo.notes || 'Nenhuma'}

INSTRU√á√ïES CR√çTICAS:
1. **AUTO-PREENCHIMENTO**: Gera automaticamente TODOS os campos necess√°rios
2. **CATEGORIA**: Escolhe a categoria MAIS ESPEC√çFICA da lista dispon√≠vel para acess√≥rios
3. **COR**: Identifica a cor PRINCIPAL/DOMINANTE da lista dispon√≠vel
4. **NOME/ID**: Cria um nome curto, descritivo e √∫til para cataloga√ß√£o de acess√≥rios
5. **TAGS**: Sugere 3-5 tags relevantes da lista de tags espec√≠ficas para acess√≥rios
6. **MARCA**: Se conseguires identificar a marca pelo design/logo, sugere
7. **AN√ÅLISE AI**: Descri√ß√£o t√©cnica focada em acess√≥rios (materiais, acabamentos, estilo, ocasi√µes de uso)

RESPOSTA EM JSON:
{
  "formData": {
    "name": "nome descritivo do acess√≥rio",
    "category": "categoria da lista dispon√≠vel",
    "color": "cor principal da lista",
    "brand": "marca identificada ou sugest√£o",
    "suggestedTags": ["tag1", "tag2", "tag3"],
    "notes": "notas autom√°ticas sobre o acess√≥rio"
  },
  "aiMetadata": "An√°lise t√©cnica detalhada do acess√≥rio: tipo, materiais aparentes, acabamentos, estilo (cl√°ssico/moderno/vintage), ocasi√µes adequadas, cuidados recomendados, versatilidade de combina√ß√£o. M√°ximo 150 palavras.",
  "confidence": {
    "category": "1-10",
    "color": "1-10", 
    "overall": "1-10"
  }
}`;

      const messages = [
        {
          role: 'user',
          content: [
            {
              type: 'text',
              text: prompt
            },
            {
              type: 'image_url',
              image_url: {
                url: imageData
              }
            }
          ]
        }
      ];

      console.log('üîÑ Gerando metadata AI para acess√≥rio:', itemInfo.name);
      const response = await callOpenAI(messages, true);
      
      try {
        // Extrair JSON da resposta
        const jsonMatch = response.match(/\{[\s\S]*\}/);
        if (!jsonMatch) {
          throw new Error('Resposta n√£o cont√©m JSON v√°lido');
        }
        
        const analysis = JSON.parse(jsonMatch[0]);
        
        // Validar estrutura da resposta
        if (!analysis.formData || !analysis.aiMetadata) {
          throw new Error('Estrutura de resposta inv√°lida');
        }
        
        // Adicionar √† hist√≥ria de an√°lises
        const analysisEntry = {
          id: Date.now(),
          itemName: analysis.formData.name,
          timestamp: new Date().toISOString(),
          metadata: analysis.aiMetadata.substring(0, 200) + '...',
          type: 'accessory'
        };
        
        setAnalysisHistory(prev => [analysisEntry, ...prev.slice(0, 9)]);
        
        console.log('‚úÖ Metadata de acess√≥rio gerada com sucesso:', analysis);
        return analysis;
        
      } catch (parseError) {
        console.error('üí• Erro ao parsear resposta JSON:', parseError);
        console.log('üîç Resposta recebida:', response);
        
        // Fallback: retornar dados b√°sicos
        return {
          formData: {
            name: itemInfo.name || 'Acess√≥rio Novo',
            category: availableCategories[0] || 'Rel√≥gios',
            color: 'Preto',
            brand: 'N√£o identificada',
            suggestedTags: ['casual'],
            notes: 'Adicionado automaticamente'
          },
          aiMetadata: response.substring(0, 500),
          confidence: {
            category: 5,
            color: 5,
            overall: 5
          }
        };
      }
      
    } catch (error) {
      console.error('üí• Erro ao gerar metadata de acess√≥rio:', error);
      throw error;
    } finally {
      setIsAnalyzing(false);
    }
  };

  // Fun√ß√£o original para roupas mantida
  const generateGarmentMetadataWithFormData = async (imageData, userProfile = {}, itemInfo = {}) => {
    if (!OPENAI_API_KEY) {
      throw new Error('API key da OpenAI n√£o configurada no sistema');
    }

    if (!imageData) {
      throw new Error('Imagem da pe√ßa √© obrigat√≥ria');
    }

    setIsAnalyzing(true);
    
    try {
      // Obter categorias dispon√≠veis baseadas no g√™nero
      const availableCategories = getClothingCategoriesByGender(userProfile?.gender);
      
      // Contexto do g√™nero
      const genderContext = userProfile?.gender ? `
PERFIL DO UTILIZADOR:
- G√™nero: ${userProfile.gender}

AN√ÅLISE ESPEC√çFICA POR G√äNERO:
${userProfile.gender === 'female' ? `
- FOCAR EM: Como a pe√ßa se adequa ao styling feminino
- CONSIDERAR: Versatilidade para ocasi√µes femininas, layering feminino
- CATEGORIZA√á√ÉO: Priorizar categorias espec√≠ficas femininas quando aplic√°vel
- NAMING: Usar terminologia feminina apropriada
` : userProfile.gender === 'male' ? `
- FOCAR EM: Como a pe√ßa se adequa ao styling masculino
- CONSIDERAR: Adequa√ß√£o a dress codes masculinos, versatilidade
- CATEGORIZA√á√ÉO: Priorizar categorias espec√≠ficas masculinas quando aplic√°vel
- NAMING: Usar terminologia masculina apropriada
` : `
- FOCAR EM: Versatilidade neutra da pe√ßa
- CONSIDERAR: Adequa√ß√£o a diferentes express√µes de g√™nero
- CATEGORIZA√á√ÉO: Usar categorias neutras e inclusivas
`}
` : '';

      const prompt = `Como especialista em an√°lise de vestu√°rio e cataloga√ß√£o digital, analisa esta imagem de uma pe√ßa de roupa e gera AUTOMATICAMENTE todos os dados necess√°rios para pr√©-preencher o formul√°rio de adi√ß√£o ao arm√°rio digital.

${genderContext}

CATEGORIAS DISPON√çVEIS:
${availableCategories.join(', ')}

CORES DISPON√çVEIS:
${COMMON_COLORS.join(', ')}

INFORMA√á√ïES FORNECIDAS PELO UTILIZADOR:
- Nome: ${itemInfo.name || 'N√£o especificado'}
- Categoria: ${itemInfo.category || 'N√£o especificada'}
- Cor: ${itemInfo.color || 'N√£o especificada'}
- Marca: ${itemInfo.brand || 'N√£o especificada'}
- Tags: ${itemInfo.tags?.join(', ') || 'Nenhuma'}
- Notas do utilizador: ${itemInfo.notes || 'Nenhuma'}

INSTRU√á√ïES CR√çTICAS:
1. **AUTO-PREENCHIMENTO**: Gera automaticamente TODOS os campos necess√°rios
2. **CATEGORIA**: Escolhe a categoria MAIS ESPEC√çFICA da lista dispon√≠vel
3. **COR**: Identifica a cor PRINCIPAL/DOMINANTE da lista dispon√≠vel
4. **NOME/ID**: Cria um nome curto, descritivo e √∫til para cataloga√ß√£o
5. **TAGS**: Sugere 3-5 tags relevantes da lista dispon√≠vel
6. **MARCA**: Se conseguires identificar a marca pelo design/logo, sugere
7. **AN√ÅLISE AI**: Descri√ß√£o t√©cnica da pe√ßa (materiais, corte, estilo, ocasi√µes)

RESPOSTA EM JSON:
{
  "formData": {
    "name": "nome descritivo da pe√ßa",
    "category": "categoria da lista dispon√≠vel",
    "color": "cor principal da lista",
    "brand": "marca identificada ou sugest√£o",
    "suggestedTags": ["tag1", "tag2", "tag3"],
    "notes": "notas autom√°ticas sobre a pe√ßa"
  },
  "aiMetadata": "An√°lise t√©cnica detalhada da pe√ßa: tipo, materiais aparentes, corte, estilo, ocasi√µes adequadas, versatilidade de combina√ß√£o. M√°ximo 150 palavras.",
  "confidence": {
    "category": "1-10",
    "color": "1-10", 
    "overall": "1-10"
  }
}`;

      const messages = [
        {
          role: 'user',
          content: [
            {
              type: 'text',
              text: prompt
            },
            {
              type: 'image_url',
              image_url: {
                url: imageData
              }
            }
          ]
        }
      ];

      console.log('üîÑ Gerando metadata AI para pe√ßa:', itemInfo.name);
      const response = await callOpenAI(messages, true);
      
      try {
        // Extrair JSON da resposta
        const jsonMatch = response.match(/\{[\s\S]*\}/);
        if (!jsonMatch) {
          throw new Error('Resposta n√£o cont√©m JSON v√°lido');
        }
        
        const analysis = JSON.parse(jsonMatch[0]);
        
        // Validar estrutura da resposta
        if (!analysis.formData || !analysis.aiMetadata) {
          throw new Error('Estrutura de resposta inv√°lida');
        }
        
        // Adicionar √† hist√≥ria de an√°lises
        const analysisEntry = {
          id: Date.now(),
          itemName: analysis.formData.name,
          timestamp: new Date().toISOString(),
          metadata: analysis.aiMetadata.substring(0, 200) + '...',
          type: 'clothing'
        };
        
        setAnalysisHistory(prev => [analysisEntry, ...prev.slice(0, 9)]);
        
        console.log('‚úÖ Metadata completa gerada com sucesso:', analysis);
        return analysis;
        
      } catch (parseError) {
        console.error('üí• Erro ao parsear resposta JSON:', parseError);
        console.log('üîç Resposta recebida:', response);
        
        // Fallback: retornar dados b√°sicos
        return {
          formData: {
            name: itemInfo.name || 'Pe√ßa Nova',
            category: availableCategories[0] || 'T-shirts',
            color: 'Preto',
            brand: 'N√£o identificada',
            suggestedTags: ['casual'],
            notes: 'Adicionado automaticamente'
          },
          aiMetadata: response.substring(0, 500),
          confidence: {
            category: 5,
            color: 5,
            overall: 5
          }
        };
      }
      
    } catch (error) {
      console.error('üí• Erro ao gerar metadata completa:', error);
      throw error;
    } finally {
      setIsAnalyzing(false);
    }
  };

  // ‚ú® FUN√á√ÉO UNIVERSAL: Determina automaticamente se √© roupa ou acess√≥rio
  const generateItemMetadataWithFormData = async (imageData, userProfile = {}, itemInfo = {}, itemType = 'auto') => {
    // Se o tipo n√£o for especificado, tentar determinar pela categoria
    if (itemType === 'auto') {
      const accessoryCategories = getAccessoryCategoriesByGender(userProfile?.gender);
      const clothingCategories = getClothingCategoriesByGender(userProfile?.gender);
      
      if (itemInfo.category && accessoryCategories.includes(itemInfo.category)) {
        itemType = 'accessory';
      } else if (itemInfo.category && clothingCategories.includes(itemInfo.category)) {
        itemType = 'clothing';
      } else {
        // Default para roupa se n√£o conseguir determinar
        itemType = 'clothing';
      }
    }

    if (itemType === 'accessory') {
      return await generateAccessoryMetadataWithFormData(imageData, userProfile, itemInfo);
    } else {
      return await generateGarmentMetadataWithFormData(imageData, userProfile, itemInfo);
    }
  };

  // Fun√ß√£o original mantida para compatibilidade
  const generateGarmentMetadata = async (imageData, itemInfo = {}) => {
    if (!OPENAI_API_KEY) {
      throw new Error('API key da OpenAI n√£o configurada no sistema');
    }

    if (!imageData) {
      throw new Error('Imagem da pe√ßa √© obrigat√≥ria');
    }

    setIsAnalyzing(true);
    
    try {
      const prompt = `Como especialista em an√°lise de vestu√°rio e moda, analisa esta imagem de uma pe√ßa de roupa/acess√≥rio e gera uma descri√ß√£o detalhada e metadata para cataloga√ß√£o digital.

INFORMA√á√ïES FORNECIDAS PELO UTILIZADOR:
- Nome: ${itemInfo.name || 'N√£o especificado'}
- Categoria: ${itemInfo.category || 'N√£o especificada'}
- Cor: ${itemInfo.color || 'N√£o especificada'}
- Marca: ${itemInfo.brand || 'N√£o especificada'}
- Tags: ${itemInfo.tags?.join(', ') || 'Nenhuma'}
- Notas do utilizador: ${itemInfo.notes || 'Nenhuma'}

AN√ÅLISE REQUERIDA:
Cria uma descri√ß√£o completa e t√©cnica da pe√ßa/acess√≥rio que inclua:

1. **IDENTIFICA√á√ÉO E TIPO**: Que tipo de item √© exatamente
2. **CARACTER√çSTICAS VISUAIS DETALHADAS**: 
   - Cores exatas e nuances observadas
   - Padr√µes, texturas, acabamentos
   - Materiais aparentes
3. **AN√ÅLISE DE ESTILO E VERSATILIDADE**:
   - Estilo espec√≠fico (casual, formal, desportivo, etc.)
   - N√≠vel de formalidade
4. **POTENCIAL DE COMBINA√á√ÉO**:
   - Como combinar com outras pe√ßas
   - Ocasi√µes adequadas
5. **CUIDADOS E MANUTEN√á√ÉO RECOMENDADOS**

IMPORTANTE: Esta informa√ß√£o ser√° usada para cataloga√ß√£o digital e recomenda√ß√µes autom√°ticas.

FORMATO DE RESPOSTA: Texto corrido descritivo, sem listas ou bullets. M√°ximo 150 palavras.`;

      const messages = [
        {
          role: 'user',
          content: [
            {
              type: 'text',
              text: prompt
            },
            {
              type: 'image_url',
              image_url: {
                url: imageData
              }
            }
          ]
        }
      ];

      console.log('üîÑ Gerando metadata AI para item:', itemInfo.name);
      const metadata = await callOpenAI(messages, true);
      
      // Adicionar √† hist√≥ria de an√°lises
      const analysisEntry = {
        id: Date.now(),
        itemName: itemInfo.name,
        timestamp: new Date().toISOString(),
        metadata: metadata.substring(0, 200) + '...',
        type: 'general'
      };
      
      setAnalysisHistory(prev => [analysisEntry, ...prev.slice(0, 9)]);
      
      console.log('‚úÖ Metadata AI gerada com sucesso');
      return metadata;
      
    } catch (error) {
      console.error('üí• Erro ao gerar metadata AI:', error);
      throw error;
    } finally {
      setIsAnalyzing(false);
    }
  };

  // ‚ú® NOVA FUN√á√ÉO: An√°lise combinada de outfit com acess√≥rios
  const analyzeOutfitWithAccessories = async (selectedClothing, selectedAccessories, occasion = null, userProfile = {}) => {
    if (!OPENAI_API_KEY) {
      throw new Error('API key da OpenAI n√£o configurada no sistema');
    }

    if ((!selectedClothing || selectedClothing.length === 0) && (!selectedAccessories || selectedAccessories.length === 0)) {
      throw new Error('Seleciona pelo menos uma pe√ßa ou acess√≥rio para an√°lise');
    }

    setIsAnalyzing(true);
    
    try {
      const genderContext = userProfile?.gender ? `
PERFIL DO UTILIZADOR:
- G√™nero: ${userProfile.gender}
- Prefer√™ncias de estilo adaptadas ao g√™nero
` : '';

      const clothingInfo = selectedClothing ? selectedClothing.map(item => 
        `${item.name} (${item.category}, ${item.color})`
      ).join('\n') : 'Nenhuma pe√ßa de roupa selecionada';

      const accessoriesInfo = selectedAccessories ? selectedAccessories.map(item => 
        `${item.name} (${item.category}, ${item.color})`
      ).join('\n') : 'Nenhum acess√≥rio selecionado';

      const prompt = `Como consultor de moda especializado, analisa esta combina√ß√£o de outfit completo incluindo roupas e acess√≥rios.

${genderContext}

PE√áAS DE ROUPA SELECIONADAS:
${clothingInfo}

ACESS√ìRIOS SELECIONADOS:
${accessoriesInfo}

OCASI√ÉO: ${occasion || 'N√£o especificada'}

AN√ÅLISE REQUERIDA:
1. **HARMONIA GERAL**: Como as pe√ßas funcionam juntas
2. **EQUIL√çBRIO DE CORES**: An√°lise da paleta de cores
3. **ADEQUA√á√ÉO √Ä OCASI√ÉO**: Se o conjunto √© apropriado
4. **PONTOS FORTES**: O que funciona bem na combina√ß√£o
5. **SUGEST√ïES DE MELHORIA**: Como otimizar o look
6. **STYLING TIPS**: Dicas espec√≠ficas para usar este outfit
7. **RATING**: Nota de 1-10 para o outfit geral

Responde de forma estruturada mas natural, focando em conselhos pr√°ticos e √∫teis.`;

      const messages = [
        {
          role: 'system',
          content: '√âs um consultor de moda experiente, especializado em combinar roupas e acess√≥rios para criar looks harmoniosos e adequados.'
        },
        {
          role: 'user',
          content: prompt
        }
      ];

      const analysis = await callOpenAI(messages);
      
      // Adicionar √† hist√≥ria
      const analysisEntry = {
        id: Date.now(),
        itemName: `Outfit: ${selectedClothing?.length || 0} pe√ßas + ${selectedAccessories?.length || 0} acess√≥rios`,
        timestamp: new Date().toISOString(),
        metadata: analysis.substring(0, 200) + '...',
        type: 'outfit'
      };
      
      setAnalysisHistory(prev => [analysisEntry, ...prev.slice(0, 9)]);
      
      return analysis;
      
    } catch (error) {
      console.error('üí• Erro ao analisar outfit:', error);
      throw error;
    } finally {
      setIsAnalyzing(false);
    }
  };

  return {
    // Fun√ß√µes existentes
    generateGarmentMetadata,
    generateGarmentMetadataWithFormData,
    
    // ‚ú® NOVAS FUN√á√ïES
    generateAccessoryMetadataWithFormData,
    generateItemMetadataWithFormData,
    analyzeOutfitWithAccessories,
    
    // Estados
    isAnalyzing,
    analysisHistory
  };
};